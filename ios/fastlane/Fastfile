# ./ios/fastlane/Fastfile
require 'dotenv/load'

# .env 파일 로드 (우선순위: ios/.env -> 프로젝트 루트 .env)
Dotenv.load(
  File.expand_path('../.env', __dir__),
  File.expand_path('../../.env', __dir__)
)

default_platform(:ios)

platform :ios do
    # 배포 전 모든 작업이 이뤄지는 곳
  before_all do
    # App Store Connect API Key로 인증 (가장 안전한 방법)
    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_API_KEY_CONTENT"], # key 파일 내용을 직접 넣거나 key_filepath 사용
      is_key_content_base64: true
    )
  end

  def with_unbundled_env
    keys = %w[
      BUNDLE_BIN_PATH
      BUNDLE_GEMFILE
      BUNDLER_ORIG_MANPATH
      BUNDLER_ORIG_PATH
      BUNDLER_VERSION
      GEM_HOME
      GEM_PATH
      RUBYLIB
      RUBYOPT
    ]

    saved = {}
    keys.each do |key|
      saved[key] = ENV[key]
      ENV.delete(key)
    end

    original_path = ENV['PATH']
    ENV['PATH'] = [
      '/opt/homebrew/bin',
      '/usr/local/bin',
      original_path
    ].compact.join(':')

    yield
  ensure
    ENV['PATH'] = original_path if defined?(original_path) && original_path
    keys.each do |key|
      value = saved[key]
      value.nil? ? ENV.delete(key) : ENV[key] = value
    end
  end

  desc "Flutter 앱을 빌드하고 TestFlight에 배포합니다."
  lane :deploy_to_testflight do
    app_identifier = ENV["APP_IDENTIFIER"] || "com.newdawn.soi-project"
    project_root = File.expand_path("../..", __dir__)

    # TestFlight에 존재하는 최신 build number 다음 값 사용 (없으면 1부터)
    latest_build = 0
    begin
      latest_build = latest_testflight_build_number(app_identifier: app_identifier)
    rescue => e
      UI.message("latest_testflight_build_number 조회 실패(초기 배포일 수 있음): #{e.message}")
      latest_build = 0
    end
    next_build_number = (latest_build.to_i + 1).to_s
    UI.message("Next build number: #{next_build_number}")

    # Bundler 환경 변수가 CocoaPods 실행을 깨뜨리는 케이스가 있어,
    # Flutter/CocoaPods 관련 커맨드는 unbundled 환경에서 실행합니다.
    with_unbundled_env do
      Dir.chdir(File.join(project_root, "ios")) do
        sh "pod --version"
        begin
          sh "pod install"
        rescue => e
          UI.user_error!(
            "CocoaPods 실행에 실패했습니다. " \
            "현재 Ruby/Bundler 환경과 CocoaPods 설치 환경이 섞였을 수 있어요. " \
            "터미널에서 `cd ios && pod --version && pod install`이 단독으로 성공하는지 확인해주세요.\n\n" \
            "원본 에러: #{e.message}"
          )
        end
      end

      Dir.chdir(project_root) do
        sh "flutter pub get"
        sh "flutter build ipa --release --build-number=#{next_build_number}"
      end
    end

    # 2. IPA 파일 경로 확인 및 설정
    # 빌드된 ipa 디렉토리에서 모든 .ipa 파일 찾기 (절대 경로 사용)
    # fastlane은 ios 폴더에서 실행되므로, 프로젝트 루트는 한 단계 위로 올라가야 함
    ipa_files = Dir.glob("#{project_root}/build/ios/ipa/*.ipa")
    
    UI.message("현재 디렉토리: #{Dir.pwd}")
    UI.message("프로젝트 루트: #{project_root}")
    UI.message("검색 경로: #{project_root}/build/ios/ipa/*.ipa")
    UI.message("찾은 IPA 파일들: #{ipa_files}")
    
    if ipa_files.empty?
      UI.user_error!("IPA 파일을 찾을 수 없습니다. 빌드가 성공했는지 확인해주세요.")
    end
    
    ipa_path = ipa_files.first
    UI.message("IPA 파일을 찾았습니다: #{ipa_path}")

    # 3. TestFlight 업로드
    pilot(
      ipa: ipa_path,
      app_identifier: app_identifier, # 앱 번들 ID
      skip_waiting_for_build_processing: true, # 빌드 처리 대기 없이 바로 다음 단계로 진행
      changelog: "이번 버전의 테스트 변경 사항입니다.", # What to Test 내용

      # 외부 테스터 배포 비활성화 (Beta App Description 필요 없음)
      distribute_external: false,

      # 수출 규제 설정 (두 번째 옵션: Apple의 운영 체제 내 표준 암호화 사용)
      uses_non_exempt_encryption: false # false = 표준 암호화만 사용 (추가 검토 불필요)
    )
  end
end
